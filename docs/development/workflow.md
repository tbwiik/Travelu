# Workflow and work-habits

## Scrum
There are a lot of different frameworks for product management one can use to have a structured and effective development process. However, scrum is one of the frameworks that emphasize continuous communication and teamwork. 

In the group, we decided on one person to be both scrum master and project manager. The project manager needs to know what the team members are developing, and the scrum master needs to know if they are using scrum correctly while doing it. Both need a clear overview of what the team is doing. Given that we also are such a small team, we find it suiting to give both roles to one person. The three other group members have the roles of being part of the team. The team members have development as their main responsibility. 

A big part of scrum is to have an iterative process where you get feedback from your client for each sprint which you can use to redirect your product onto the right path. In this way, the team figures out what the end product should look like while developing instead of having a clear vision of the end goal from the beginning. Since we are not getting any feedback along the way, the iterative part of scrum is lost. To make up for this, we look at the app's functionality at the end of each sprint and reflect on what works fine and what needs improvement to make a clear path for what needs to be done forward. 

## Sprints
Each time our group is handed a new assignment, we set up sprints to have a concrete plan of what we are going to do next. Usually, we create one sprint per week. This makes it so the group spreads the work evenly across weeks which helps us avoid having to do most of the work a couple of days before the end of the release. Having sprints is a good way of creating deadlines for which issues we will finish at what time and it creates a straightforward plan for what needs to be done.

### Meetings
Each week we arrange at least two meetings. The first one being on Monday and the second one on Friday. 

Each meeting on Mondays is split in half. The first half is dedicated to a sprint review where the group looks back at the last sprint and reflects on what worked well and what didn't. We then try to find out why it didnâ€™t work well and use this to figure out how we can do things better in the next sprint. 

The second half of the meeting on Mondays is spent on sprint planning. Here we have our thoughts from the sprint review fresh in mind which makes it easier to make a plan based on our reflections regarding the last sprint. We have therefore set up the sprint review and sprint planning right after each other. In the sprint planning meeting, we discuss what we are going to accomplish in the next sprint and how we are going to accomplish it. This involves creating issues, assigning them to the group members, and setting up additional meetings for developing together. A clear plan makes the development process less stressful and gives the group members a good overview of what is going to be done during the next few days. When each member knows what they have to do until the next meeting, they can more easily get to work and be effective.

All other meetings we have are treated as daily scrums. Here we discuss what we have done so far and what we are going to do that day to make sure everyone is keeping track of what is being done. Afterwards, we talk about any problems we have encountered while developing. Sometimes a member can be stuck on a problem for a long time while another member of the team has a solution. Therefore, going over problems with the entire group can save a lot of time. When the problems have been discussed, we then end the meeting and start to develop together.

### Issues
Each time we are given a new group assignment, we analyse the problem and divide it into subtasks. We then create an issue for each of the individual tasks that need to be done. The issues involve creating documentation, classes, tests, methods, and more. The issues help us by defining clear goals that make it easy to go from one task to the next and remove uncertainty. To have a good overview of all the tasks we have a scrum board that contains all the issues. 

When it comes to choosing who does what, we try to make it so everyone gets to both program and write documentation. This is beneficial because it makes for a stronger connection between code and documentation as well as allowing for more variation in each member's work. We start by assigning some issues to the members of the group. If some issues are correlated, we assign the correlating issues to the same group member. After this, we get to work and create and assign more issues when we encounter new problems. Even though we try to cover all of the tasks needing to be done with issues, there are inevitably going to be issues like bug fixing and handy features that are going to emerge along the way. 

Each issue has some key information that makes it easier to categorise and understand them. They all have a title and description explaining what needs to be done to solve the issue. Some of the issues are also given a time estimate which lets us approximate how much time we need to set aside to complete the issues before the end of the sprint. Additionally, we give each issue multiple labels to make it easy to recognize what type of issue it is. For example, issues revolving writing documentation get the label "documentation". Other similar labels are "tests", "frontend", "backend", and "enhancement". We also give labels to show the priority and state of the issue like "high priority" and "doing" if it is a high-priority task that is currently being worked on. 

### Programming flow
Every time we are going to work on an issue, we assign a group member to it, give it the label "doing" and create a merge request for it. By creating a merge request, we show everyone what we are working on while simultaneously creating a branch where the work is going to be done. Here we initially planned to follow the branch naming convention "issuenumber-type-issuename" from https://codingsight.com/git-branching-naming-convention-best-practices/. However, we found that using the generated branch names ("issuenumber-issuename") from GitLab was easier, more convenient, and more consistent. 

When a member is done with their issue, they mark their merge request as ready for review. Someone else on the team then reviews the code and gives feedback. If the code is good, the reviewer approves the merge request and the code is merged into the main branch. However, when the merge request impacts a huge part of the project, we make more than one person review the code before it gets merged. Having someone review the code ensured that the code is of good quality and that it works as intended. It also makes it so that the code is more understandable for the rest of the group and makes everyone get a good understanding of the entire project. If the reviewer finds any problems with the code, they give feedback to the developer by commenting on the merge request. The developer then fixes the problems and the reviewer reviews the code again. This process continues until the reviewer approves the merge request.

When working on issues, we try to have a structured way of working on each problem by working in one place in the code at a time. If we work on code in multiple methods, we place the code for each method in their own commit messages. This makes it easy to revert to old changes and immediately understand what the commit was about. When writing commit messages, we use the convention "type: message" written in present form from https://www.conventionalcommits.org/en/v1.0.0/#specification. 

Furthermore, we develop both together and for ourselves. When we are implementing simple methods and writing documentation, we tend to do this individually. This allows us to work without being physically gathered, and can save time if the tasks aren't that demanding. When we develop without being physically gathered, we focus on having continuous communication between the group members through Teams to make sure everyone is always up to date on what everyone is doing.

However, when we are working on complex problems like modularization and implementing complicated methods, we prefer to program in pairs. This is because it is easy to get lost in the many small but important details of complex problems while developing. Thus, having two people looking at the same problem at once makes it easier to always have a good overview of the project and remember those details. When two people are programming together they can also continuously discuss the best way to implement something. We find developing in pairs and individually to both have their use cases and switching between them to be the best way to develop.